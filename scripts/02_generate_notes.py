import json
import os
from typing import List
from openai import OpenAI
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

class Note(BaseModel):
    id: int = Field(..., ge=1, le=10)
    heading: str = Field(..., example="Mean Value Theorem")
    summary: str = Field(..., max_length=150)
    page_ref: int | None = Field(None, description="Page number in source PDF")
    
def generate_notes() -> List[Note]:
    with open("assistant_id.txt") as f:
        assistant_id = f.read().strip()

    # Ð¡Ð¾Ð·Ð´Ð°Ð¹ thread Ð¸ ÑÑ€Ð°Ð·Ñƒ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸
    run = client.beta.threads.create_and_run(
        assistant_id=assistant_id,
        thread={"messages": [
            {
                "role": "user",
                "content": (
                    "Please generate exactly 10 concise exam revision notes "
                    "based on the uploaded PDF. "
                    "Each note must include an id (1â€“10), a heading, a short summary "
                    "(max 150 characters), and a page_ref if available. "
                    "Respond only with valid JSON matching the Note[] schema."
                )
            }
        ]},
        response_format={"type": "json_object"}
    )

    # ÐŸÐ¾Ð´Ð¾Ð¶Ð´Ð¸ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ
    import time
    while True:
        run_status = client.beta.threads.runs.retrieve(
            thread_id=run.thread_id,
            run_id=run.id
        )
        if run_status.status == "completed":
            break
        elif run_status.status == "failed":
            raise RuntimeError("Run failed.")
        time.sleep(1)

    # ÐŸÐ¾Ð»ÑƒÑ‡Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
    messages = client.beta.threads.messages.list(thread_id=run.thread_id)
    content = messages.data[0].content[0].text.value
    data = json.loads(content)
    return [Note(**item) for item in data["notes"]]


def print_pretty_notes(notes: List[Note]):
    # Print header
    print("\n" + "=" * 80)
    print("ðŸ“š EXAM STUDY NOTES".center(80))
    print("Generated by Study Assistant".center(80))
    print("=" * 80 + "\n")
    
    # Calculate column widths
    id_width = 3
    topic_width = max(len(note.heading) for note in notes)
    topic_width = min(max(topic_width, 20), 30)  # Between 20 and 30 chars
    page_width = 6
    summary_width = 80 - (id_width + topic_width + page_width + 6)  # 6 for spacing
    
    # Print column headers
    header_format = f"{{:>{id_width}}} | {{:<{topic_width}}} | {{:<{summary_width}}} | {{:>{page_width}}}"
    print(header_format.format("#", "TOPIC", "SUMMARY", "PAGE"))
    print("-" * 80)
    
    # Print each note
    row_format = f"{{:>{id_width}}} | {{:<{topic_width}}} | {{:<{summary_width}}} | {{:>{page_width}}}"
    for note in notes:
        # Truncate long text and add ellipsis if necessary
        heading = note.heading[:topic_width-3] + "..." if len(note.heading) > topic_width else note.heading
        summary = note.summary[:summary_width-3] + "..." if len(note.summary) > summary_width else note.summary
        page = str(note.page_ref) if note.page_ref else "N/A"
        
        print(row_format.format(
            note.id,
            heading,
            summary,
            page
        ))
    
    print("\n" + "=" * 80)

def save_notes_to_json(notes: List[Note], filename: str = "exam_notes.json"):
    with open(filename, "w") as f:
        json.dump(
            {"notes": [note.model_dump() for note in notes]},
            f,
            indent=2
        )
    print(f"\nNotes saved to {filename}")

def main():
    print("Generating study notes...")
    notes = generate_notes()
    
    # Print the notes in a formatted way
    print_pretty_notes(notes)
    
    # Save to JSON
    save_notes_to_json(notes)

if __name__ == "__main__":
    main()